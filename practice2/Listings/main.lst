C51 COMPILER V9.60.0.0   MAIN                                                              02/08/2025 02:35:30 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          
   3          sfr P4    = 0xe8;                   //for 89C5xRC/RD+ series and 90C5xRc/RD+, location at 0E8H
   4          //sfr P4   = 0xc0;                  //for 90C5xAD series, location at 0C0H
   5          sbit INT2 = P4^3;
   6          sbit INT3 = P4^2;
   7          
   8          sfr XICON = 0xc0;                   //for 89C5xRC/RD+ series and 90C5xRc/RD+, location at 0C0H
   9          //sfr XICON = 0xe8;                 //for 90C5xAD series, location at 0E8H
  10          sbit PX3  = XICON^7;
  11          sbit EX3  = XICON^6;
  12          sbit IE3  = XICON^5;
  13          sbit IT3  = XICON^4;
  14          sbit PX2  = XICON^3;
  15          sbit EX2  = XICON^2;
  16          sbit IE2  = XICON^1;
  17          sbit IT2  = XICON^0;
  18          
  19          sfr IPH = 0xB7; // 定义默认值，否则无法使用（用于定义中断优先级）
  20          
  21          sbit key1 = P4^3;
  22          
  23          #define TIMS (65536-9216)
  24          static unsigned int count = 0;
  25          
  26          sbit ds_pin = P0^3;
  27          sbit stcp_pin = P0^4;
  28          sbit shcp_pin = P0^5;
  29          
  30          // 记录按键状态
  31          static unsigned int state = 0; // 0 --- 清零重新计数，~0 --- 暂停计数
  32          
  33          //共阴 数码管数组：0-9
  34          unsigned char num[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
  35          
  36          // 延时函数
  37          void delay_ms(unsigned int xms)   //@12MHz
  38          {
  39   1          unsigned int i, j;
  40   1          for (i = xms; i > 0; i--) {
  41   2              for (j = 124; j > 0; j--) {}
  42   2          }
  43   1      }
  44          
  45          void hc595_send_byte(unsigned char byte){
  46   1          unsigned int i;
  47   1          for (i = 0; i < 8; ++i) {
  48   2              // 串行输入引脚，即数据在一根信号线上按顺序一位位地传输
  49   2              if (byte & 0x80)
  50   2                  ds_pin = 1;
  51   2              else
  52   2                  ds_pin = 0;
  53   2              // SHCP发生一次上升沿，芯片从DS引脚上获取当前数据
  54   2              shcp_pin = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/08/2025 02:35:30 PAGE 2   

  55   2              shcp_pin = 1;
  56   2              byte <<= 1;
  57   2          }
  58   1      }
  59          
  60          // num-需要显示的内容 addr-在哪个数码管显示
  61          void hc595_send_data(unsigned char num,unsigned char addr){
  62   1          // 先发需要显示的数字
  63   1          hc595_send_byte(num);
  64   1          // 将移位寄存器填满后，再往移位寄存器中塞数据，数据会被从9脚输出
  65   1          // 再发需要点亮的数码管，这时候移位寄存器中的数据被移位到芯片2中
  66   1          if(addr == 0)
  67   1              // Q0控制 0b1111 1110 0xFE
  68   1              hc595_send_byte(0xFE);
  69   1          else if(addr == 1)
  70   1              // Q1控制 0b1111 1101 0xFD
  71   1              hc595_send_byte(0xFD);
  72   1          // 移位寄存器的8位数据全传输完毕后，制造一次锁存寄存器引脚的上升沿
  73   1          stcp_pin = 0;
  74   1          stcp_pin = 1;
  75   1      }
  76          
  77          //10ms执行一次
  78          void Timer0() interrupt 1 {
  79   1          //1000毫秒执行一次计数
  80   1          if(count < 9900){
  81   2              count++;
  82   2          }
  83   1          //每次产生中断后重新设置下次定时器初值 - 10毫秒产生1次中断
  84   1          TH0 = TIMS >> 8;
  85   1          TL0 = TIMS;
  86   1      }
  87          
  88          void exit2() interrupt 6 {
  89   1          //当按键按下时灯切换
  90   1          if (key1 == 0) {
  91   2              if (state == 0) {
  92   3                  //当前状态为计数状态，下一个状态暂停计数
  93   3                  //通过关闭计数器，使程序暂停计数
  94   3                  TR0 = 0; //定时器计数关闭
  95   3              } else {
  96   3                  //当前状态为计数状态，下一个状态重新计数
  97   3                  //通过开启计数器，程序重新计数
  98   3                  count = 0;
  99   3                  TR0 = 1; //定时器计数开启
 100   3                  //设置预装载值 使得定时时间是10ms
 101   3                  TL0 = TIMS; //0b0000 0000
 102   3                  TH0 = TIMS >> 8; //1101 1100
 103   3              }
 104   2              //改变状态变量
 105   2              state = ~state;
 106   2              delay_ms(10);
 107   2          }
 108   1      }
 109          
 110          void main() {
 111   1          IT2 = 1; // 设置外部中断2的触发条件为下降沿
 112   1          EX2 = 1; // 运行中断2经过
 113   1          TMOD = 0x01;                    //配置定时器0为16位定时器，TH0、TL0全用
 114   1          TH0 = TIMS >> 8;                //设置定时初值高8位
 115   1          TL0 = TIMS;                     //设置定时初值低8位
 116   1          ET0 = 1;  //开启定时器0中断
C51 COMPILER V9.60.0.0   MAIN                                                              02/08/2025 02:35:30 PAGE 3   

 117   1          EA  = 1;  //开启全局中断
 118   1          TR0 = 1;  //定时器0开始计数
 119   1          IPH = 0x60; // 设置中断优先级，INT2 > Time0,PX2H=PX2=1，PT0H=PT0=0； 0b 0110 0000
 120   1          //PT0H = 0;
 121   1          //PT0 = 0;
 122   1          while(1){
 123   2              //在第一个数码管显示数字
 124   2              hc595_send_data(num[count / 1000], 0);
 125   2              //在第二个数码管显示数字
 126   2              hc595_send_data(num[(count / 100) % 10], 1);
 127   2          };
 128   1      }
 129          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    269    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
